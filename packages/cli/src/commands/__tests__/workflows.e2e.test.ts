/**
 * ============================================================================
 * AUTOGENERATED E2E TEST FILE - DO NOT MODIFY MANUALLY
 * ============================================================================
 *
 * This file is automatically generated based on the E2E test specifications.
 * Any manual changes will be overwritten by the automation.
 *
 * To modify these tests, update the specification files:
 * - /docs/E2E_TESTS.md (root-level testing philosophy and constraints)
 * - /packages/cli/E2E_TESTS.md (CLI-specific test specifications)
 *
 * Then run the /update-e2e-tests command to regenerate this file.
 * ============================================================================
 */

import { beforeEach, afterEach, describe, it, expect } from 'vitest';
import { SKIP_REAL_AGENT_TESTS } from './e2e-utils.js';
import {
  mkdtempSync,
  rmSync,
  writeFileSync,
  readFileSync,
  existsSync,
  mkdirSync,
  chmodSync,
} from 'node:fs';
import { tmpdir } from 'node:os';
import { join } from 'node:path';
import { execa } from 'execa';

/**
 * E2E tests for `rover workflows` command group
 *
 * These tests run the actual rover CLI binary and test the full workflow management.
 * They mock system tool availability by creating wrapper scripts in a temporary bin directory.
 */

describe('rover workflows (e2e)', () => {
  let testDir: string;
  let originalCwd: string;
  let mockBinDir: string;
  let mockHomeDir: string;
  let originalPath: string;

  const createMockTool = (
    toolName: string,
    exitCode: number = 0,
    output: string = 'mock version 1.0.0'
  ) => {
    const scriptPath = join(mockBinDir, toolName);
    const scriptContent = `#!/usr/bin/env bash\necho "${output}"\nexit ${exitCode}`;
    writeFileSync(scriptPath, scriptContent);
    chmodSync(scriptPath, 0o755);
  };

  const createMockScript = (toolName: string, scriptContent: string) => {
    const scriptPath = join(mockBinDir, toolName);
    writeFileSync(scriptPath, scriptContent);
    chmodSync(scriptPath, 0o755);
  };

  const createMockClaude = () => {
    createMockScript(
      'claude',
      `#!/usr/bin/env bash
if [[ "$1" == "--version" ]]; then
  echo "Claude CLI v1.0.0"
  exit 0
fi

if [[ "$1" == "-p" ]]; then
  PROMPT=$(cat)
  if [[ "$2" == "--output-format" && "$3" == "json" ]]; then
    echo '{"result":"{\\"title\\":\\"Test task\\",\\"description\\":\\"A test task description.\\"}"}'
  else
    echo '{"title":"Test task","description":"A test task description."}'
  fi
  exit 0
fi

echo "Claude CLI v1.0.0"
exit 0
`
    );
  };

  const roverBin = join(__dirname, '../../../dist/index.mjs');

  const runRover = async (args: string[]) => {
    const testPath = `${mockBinDir}:${originalPath}`;
    return execa('node', [roverBin, ...args], {
      cwd: testDir,
      env: {
        PATH: testPath,
        HOME: mockHomeDir,
        USER: process.env.USER,
        TMPDIR: process.env.TMPDIR,
        ROVER_NO_TELEMETRY: '1',
      },
      reject: false,
    });
  };

  /**
   * Valid workflow YAML with required id and type fields for each step
   */
  const sampleWorkflowYaml = `name: test-workflow
description: A test workflow for e2e testing
version: "1.0"
steps:
  - id: analyze
    name: Analyze
    type: agent
    description: Analyze the codebase
    prompt: "Analyze the codebase and identify improvements"
  - id: implement
    name: Implement
    type: agent
    description: Implement changes
    prompt: "Implement the identified improvements"
`;

  /**
   * Workflow YAML with command type steps only
   */
  const commandWorkflowYaml = `name: command-workflow
description: A workflow with command steps for testing
version: "1.0"
steps:
  - id: check
    name: Check environment
    type: command
    command: echo
    args:
      - "hello from command step"
  - id: list-files
    name: List files
    type: command
    command: ls
    args:
      - "-la"
`;

  /**
   * Workflow YAML with a command step that uses allow_failure
   */
  const commandAllowFailureWorkflowYaml = `name: command-allow-failure
description: A workflow with allow_failure command step
version: "1.0"
steps:
  - id: failing-step
    name: Failing step
    type: command
    command: "false"
    allow_failure: true
  - id: next-step
    name: Next step
    type: command
    command: echo
    args:
      - "continued after failure"
`;

  /**
   * Workflow YAML with a failing command step (no allow_failure)
   */
  const failingCommandWorkflowYaml = `name: failing-command
description: A workflow with a failing command step
version: "1.0"
steps:
  - id: fail
    name: Fail step
    type: command
    command: "false"
  - id: next
    name: Next step (should not run)
    type: command
    command: echo
    args:
      - "should not reach here"
`;

  /**
   * Workflow YAML with mixed agent and command steps
   */
  const mixedWorkflowYaml = `name: mixed-workflow
description: A workflow with both agent and command steps
version: "1.0"
steps:
  - id: build
    name: Build
    type: command
    command: echo
    args:
      - "building..."
  - id: analyze
    name: Analyze
    type: agent
    description: Analyze the build output
    prompt: "Analyze the codebase"
  - id: lint
    name: Lint
    type: command
    command: echo
    args:
      - "linting..."
`;

  beforeEach(async () => {
    originalCwd = process.cwd();
    originalPath = process.env.PATH || '';

    testDir = mkdtempSync(join(tmpdir(), 'rover-workflows-e2e-'));
    process.chdir(testDir);

    mockBinDir = join(testDir, '.mock-bin');
    mkdirSync(mockBinDir, { recursive: true });

    // Create mock HOME directory with agent configuration files
    mockHomeDir = join(testDir, '.mock-home');
    mkdirSync(mockHomeDir, { recursive: true });
    writeFileSync(
      join(mockHomeDir, '.claude.json'),
      JSON.stringify({ version: 1 })
    );

    process.env.PATH = `${mockBinDir}:${originalPath}`;

    createMockTool('docker', 127, 'command not found: docker');
    createMockTool('claude', 127, 'command not found: claude');
    createMockTool('codex', 127, 'command not found: codex');
    createMockTool('cursor', 127, 'command not found: cursor');
    createMockTool('cursor-agent', 127, 'command not found: cursor-agent');
    createMockTool('gemini', 127, 'command not found: gemini');
    createMockTool('qwen', 127, 'command not found: qwen');
    createMockTool('opencode', 127, 'command not found: opencode');

    createMockTool('docker', 0, 'Docker version 24.0.0');
    createMockClaude();

    await execa('git', ['init']);
    await execa('git', ['config', 'user.email', 'test@test.com']);
    await execa('git', ['config', 'user.name', 'Test User']);
    await execa('git', ['config', 'commit.gpgsign', 'false']);

    writeFileSync(
      'package.json',
      JSON.stringify(
        { name: 'test-project', version: '1.0.0', type: 'module' },
        null,
        2
      )
    );
    writeFileSync('README.md', '# Test Project\n');

    await execa('git', ['add', '.']);
    await execa('git', ['commit', '-m', 'Initial commit']);

    await runRover(['init', '--yes']);
  });

  afterEach(() => {
    process.chdir(originalCwd);
    process.env.PATH = originalPath;
    rmSync(testDir, { recursive: true, force: true });
  });

  describe('add workflow from URL', () => {
    it('should add a workflow from an HTTP URL', async () => {
      // Start a simple HTTP server to serve the workflow YAML
      const { createServer } = await import('node:http');
      const server = createServer((_req, res) => {
        res.writeHead(200, { 'Content-Type': 'text/yaml' });
        res.end(sampleWorkflowYaml);
      });

      await new Promise<void>(resolve => {
        server.listen(0, '127.0.0.1', () => resolve());
      });

      const address = server.address();
      const port =
        typeof address === 'object' && address !== null ? address.port : 0;

      try {
        const result = await runRover([
          'workflows',
          'add',
          `http://127.0.0.1:${port}/test-workflow.yml`,
          '--name',
          'url-workflow',
          '--json',
        ]);

        expect(result.exitCode).toBe(0);

        const output = JSON.parse(result.stdout);
        expect(output.success).toBe(true);
        expect(output.workflow).toBeDefined();
        expect(output.workflow.name).toBe('url-workflow');
      } finally {
        server.close();
      }
    });

    it('should allow setting a custom name with --name flag when adding from URL', async () => {
      const { createServer } = await import('node:http');
      const server = createServer((_req, res) => {
        res.writeHead(200, { 'Content-Type': 'text/yaml' });
        res.end(sampleWorkflowYaml);
      });

      await new Promise<void>(resolve => {
        server.listen(0, '127.0.0.1', () => resolve());
      });

      const address = server.address();
      const port =
        typeof address === 'object' && address !== null ? address.port : 0;

      try {
        const result = await runRover([
          'workflows',
          'add',
          `http://127.0.0.1:${port}/workflow.yml`,
          '--name',
          'custom-url-workflow',
          '--json',
        ]);

        expect(result.exitCode).toBe(0);

        const output = JSON.parse(result.stdout);
        expect(output.success).toBe(true);
        expect(output.workflow.name).toBe('custom-url-workflow');
      } finally {
        server.close();
      }
    });

    it('should save URL workflow to global store with --global flag', async () => {
      const { createServer } = await import('node:http');
      const server = createServer((_req, res) => {
        res.writeHead(200, { 'Content-Type': 'text/yaml' });
        res.end(sampleWorkflowYaml);
      });

      await new Promise<void>(resolve => {
        server.listen(0, '127.0.0.1', () => resolve());
      });

      const address = server.address();
      const port =
        typeof address === 'object' && address !== null ? address.port : 0;

      const globalName = `e2e-global-url-${Date.now()}`;

      try {
        const result = await runRover([
          'workflows',
          'add',
          `http://127.0.0.1:${port}/workflow.yml`,
          '--global',
          '--name',
          globalName,
          '--json',
        ]);

        expect(result.exitCode).toBe(0);

        const output = JSON.parse(result.stdout);
        expect(output.success).toBe(true);
        expect(output.workflow.store).toBe('global');

        // Clean up global workflow
        const globalPath = output.workflow.path;
        if (globalPath && existsSync(globalPath)) {
          rmSync(globalPath);
        }
      } finally {
        server.close();
      }
    });
  });

  describe('add workflow from file', () => {
    it('should add a workflow from a local file path', async () => {
      const workflowFile = join(testDir, 'my-workflow.yml');
      writeFileSync(workflowFile, sampleWorkflowYaml);

      const result = await runRover([
        'workflows',
        'add',
        workflowFile,
        '--json',
      ]);

      expect(result.exitCode).toBe(0);

      const output = JSON.parse(result.stdout);
      expect(output.success).toBe(true);
      expect(output.workflow).toBeDefined();
      expect(output.workflow.name).toBeDefined();
      expect(output.workflow.path).toBeDefined();
    });

    it('should allow setting a custom name with --name flag', async () => {
      const workflowFile = join(testDir, 'my-workflow.yml');
      writeFileSync(workflowFile, sampleWorkflowYaml);

      const result = await runRover([
        'workflows',
        'add',
        workflowFile,
        '--name',
        'custom-name',
        '--json',
      ]);

      expect(result.exitCode).toBe(0);

      const output = JSON.parse(result.stdout);
      expect(output.success).toBe(true);
      expect(output.workflow.name).toBe('custom-name');
    });

    it('should save to global store with --global flag', async () => {
      const workflowFile = join(testDir, 'my-workflow.yml');
      writeFileSync(workflowFile, sampleWorkflowYaml);

      const globalName = `e2e-global-${Date.now()}`;
      const result = await runRover([
        'workflows',
        'add',
        workflowFile,
        '--global',
        '--name',
        globalName,
        '--json',
      ]);

      expect(result.exitCode).toBe(0);

      const output = JSON.parse(result.stdout);
      expect(output.success).toBe(true);
      expect(output.workflow.store).toBe('global');

      // Clean up global workflow
      const globalPath = output.workflow.path;
      if (globalPath && existsSync(globalPath)) {
        rmSync(globalPath);
      }
    });
  });

  describe('add workflow from stdin', () => {
    it('should add a workflow from stdin when source is -', async () => {
      const result = await execa(
        'node',
        [
          roverBin,
          'workflows',
          'add',
          '-',
          '--name',
          'stdin-workflow',
          '--json',
        ],
        {
          cwd: testDir,
          env: {
            PATH: `${mockBinDir}:${originalPath}`,
            HOME: mockHomeDir,
            USER: process.env.USER,
            TMPDIR: process.env.TMPDIR,
            ROVER_NO_TELEMETRY: '1',
          },
          input: sampleWorkflowYaml,
          reject: false,
        }
      );

      expect(result.exitCode).toBe(0);

      const output = JSON.parse(result.stdout);
      expect(output.success).toBe(true);
      expect(output.workflow.name).toBe('stdin-workflow');
    });
  });

  describe('list workflows', () => {
    it('should display all available workflows', async () => {
      const result = await runRover(['workflows', 'list', '--json']);

      expect(result.exitCode).toBe(0);

      const output = JSON.parse(result.stdout);
      expect(output.success).toBe(true);
      expect(Array.isArray(output.workflows)).toBe(true);
      // Should at least have the built-in 'swe' workflow
      expect(output.workflows.length).toBeGreaterThanOrEqual(1);
    });

    it('should show workflow name, description, steps, inputs, and source', async () => {
      // Add a custom workflow first
      const workflowFile = join(testDir, 'my-workflow.yml');
      writeFileSync(workflowFile, sampleWorkflowYaml);
      await runRover(['workflows', 'add', workflowFile, '--json']);

      // List workflows
      const result = await runRover(['workflows', 'list', '--json']);
      expect(result.exitCode).toBe(0);

      const output = JSON.parse(result.stdout);
      expect(output.workflows.length).toBeGreaterThanOrEqual(1);

      // Check the built-in swe workflow has key fields
      const sweWorkflow = output.workflows.find(
        (w: { name: string }) => w.name === 'swe'
      );
      expect(sweWorkflow).toBeDefined();
      expect(sweWorkflow.name).toBeDefined();
      expect(sweWorkflow.description).toBeDefined();
      expect(sweWorkflow.source).toBeDefined();
      expect(Array.isArray(sweWorkflow.steps)).toBe(true);
      expect(sweWorkflow.steps.length).toBeGreaterThan(0);
      expect(sweWorkflow.inputs).toBeDefined();
    });

    it('should work with the ls alias', async () => {
      const result = await runRover(['workflows', 'ls', '--json']);

      expect(result.exitCode).toBe(0);

      const output = JSON.parse(result.stdout);
      expect(output.success).toBe(true);
      expect(Array.isArray(output.workflows)).toBe(true);
    });
  });

  describe('inspect workflow', () => {
    it('should display detailed information about a specific workflow', async () => {
      // Inspect the built-in swe workflow
      const result = await runRover(['workflows', 'inspect', 'swe', '--json']);

      expect(result.exitCode).toBe(0);

      const output = JSON.parse(result.stdout);
      expect(output.success).toBe(true);
      expect(output.workflow).toBeDefined();
      expect(output.workflow.name).toBe('swe');
      expect(output.workflow.description).toBeDefined();
      expect(output.workflow.steps).toBeDefined();
      expect(Array.isArray(output.workflow.steps)).toBe(true);
      expect(output.workflow.steps.length).toBeGreaterThan(0);
      expect(output.workflow.inputs).toBeDefined();
    });

    it('should show raw YAML content with --raw flag', async () => {
      const result = await runRover(['workflows', 'inspect', 'swe', '--raw']);

      expect(result.exitCode).toBe(0);
      // Raw output should contain YAML content
      expect(result.stdout).toContain('name:');
      expect(result.stdout).toContain('steps:');
    });

    it('should inspect a workflow directly from a file path', async () => {
      const workflowFile = join(testDir, 'my-workflow.yml');
      writeFileSync(workflowFile, sampleWorkflowYaml);

      const result = await runRover([
        'workflows',
        'inspect',
        workflowFile,
        '--json',
      ]);

      expect(result.exitCode).toBe(0);

      const output = JSON.parse(result.stdout);
      expect(output.success).toBe(true);
      expect(output.workflow).toBeDefined();
      expect(output.workflow.name).toBeDefined();
    });
  });

  describe('workflow with command step execution', () => {
    it('should add a workflow containing command type steps', async () => {
      const workflowFile = join(testDir, 'command-workflow.yml');
      writeFileSync(workflowFile, commandWorkflowYaml);

      const result = await runRover([
        'workflows',
        'add',
        workflowFile,
        '--json',
      ]);

      expect(result.exitCode).toBe(0);

      const output = JSON.parse(result.stdout);
      expect(output.success).toBe(true);
      expect(output.workflow).toBeDefined();
      expect(output.workflow.name).toBe('command-workflow');
    });

    it('should display command step type when inspecting a workflow with command steps', async () => {
      const workflowFile = join(testDir, 'command-workflow.yml');
      writeFileSync(workflowFile, commandWorkflowYaml);

      await runRover(['workflows', 'add', workflowFile, '--json']);

      const result = await runRover([
        'workflows',
        'inspect',
        'command-workflow',
        '--json',
      ]);

      expect(result.exitCode).toBe(0);

      const output = JSON.parse(result.stdout);
      expect(output.workflow.steps).toBeDefined();
      expect(output.workflow.steps.length).toBe(2);
      // Verify all steps are of type 'command'
      expect(
        output.workflow.steps.every(
          (s: { type: string }) => s.type === 'command'
        )
      ).toBe(true);
    });

    it('should add a workflow with allow_failure on command steps', async () => {
      const workflowFile = join(testDir, 'allow-failure-workflow.yml');
      writeFileSync(workflowFile, commandAllowFailureWorkflowYaml);

      const result = await runRover([
        'workflows',
        'add',
        workflowFile,
        '--name',
        'command-allow-failure',
        '--json',
      ]);

      expect(result.exitCode).toBe(0);

      const output = JSON.parse(result.stdout);
      expect(output.success).toBe(true);
      expect(output.workflow.name).toBe('command-allow-failure');
    });

    it('should add a workflow with mixed agent and command step types', async () => {
      const workflowFile = join(testDir, 'mixed-workflow.yml');
      writeFileSync(workflowFile, mixedWorkflowYaml);

      const result = await runRover([
        'workflows',
        'add',
        workflowFile,
        '--json',
      ]);

      expect(result.exitCode).toBe(0);

      const output = JSON.parse(result.stdout);
      expect(output.success).toBe(true);
      expect(output.workflow.name).toBe('mixed-workflow');
    });

    it('should show mixed step types when inspecting a workflow with both agent and command steps', async () => {
      const workflowFile = join(testDir, 'mixed-workflow.yml');
      writeFileSync(workflowFile, mixedWorkflowYaml);

      await runRover(['workflows', 'add', workflowFile, '--json']);

      const result = await runRover([
        'workflows',
        'inspect',
        'mixed-workflow',
        '--json',
      ]);

      expect(result.exitCode).toBe(0);

      const output = JSON.parse(result.stdout);
      expect(output.workflow.steps.length).toBe(3);
      const stepTypes = output.workflow.steps.map(
        (s: { type: string }) => s.type
      );
      expect(stepTypes).toContain('command');
      expect(stepTypes).toContain('agent');
    });

    /**
     * SKIPPED: Tests require real AI agent execution
     *
     * Why skipped:
     *   Command step execution tests require the workflow to actually run inside a
     *   Docker container. With mock Docker, workflows never execute, so command step
     *   behavior cannot be verified.
     *
     * TODO: To unskip these tests:
     *   1. Set ROVER_E2E_REAL_AGENT=true environment variable
     *   2. Ensure Docker is running and can pull the rover agent image
     *   3. Ensure a valid AI agent (Claude CLI, Gemini CLI, etc.) is installed and authenticated
     *   4. Run with: ROVER_E2E_REAL_AGENT=true pnpm e2e-test --grep "command step execution behavior"
     */
    describe.skipIf(SKIP_REAL_AGENT_TESTS)(
      'command step execution behavior',
      () => {
        const waitForTaskTerminal = async (
          taskId: number,
          timeoutMs: number = 600000
        ): Promise<string> => {
          const startTime = Date.now();
          while (Date.now() - startTime < timeoutMs) {
            const inspectResult = await runRover([
              'inspect',
              String(taskId),
              '--json',
            ]);
            if (inspectResult.exitCode === 0) {
              const task = JSON.parse(inspectResult.stdout);
              if (task.status === 'COMPLETED' || task.status === 'FAILED') {
                return task.status;
              }
            }
            await new Promise(resolve => setTimeout(resolve, 2000));
          }
          throw new Error(
            `Timeout waiting for task ${taskId} to reach terminal status`
          );
        };

        it('should execute a command step successfully and capture its output', async () => {
          const workflowFile = join(testDir, 'command-workflow.yml');
          writeFileSync(workflowFile, commandWorkflowYaml);

          await runRover(['workflows', 'add', workflowFile, '--json']);

          const result = await runRover([
            'task',
            '-y',
            'Run command workflow',
            '--workflow',
            'command-workflow',
            '--json',
          ]);

          expect(result.exitCode).toBe(0);

          const status = await waitForTaskTerminal(1);
          expect(status).toBe('COMPLETED');
        });

        it('should stop workflow when command step fails without allow_failure', async () => {
          const workflowFile = join(testDir, 'failing-command-workflow.yml');
          writeFileSync(workflowFile, failingCommandWorkflowYaml);

          await runRover(['workflows', 'add', workflowFile, '--json']);

          const result = await runRover([
            'task',
            '-y',
            'Run failing command workflow',
            '--workflow',
            'failing-command',
            '--json',
          ]);

          expect(result.exitCode).toBe(0);

          const status = await waitForTaskTerminal(1);
          // Workflow should fail because command step failed
          expect(status).toBe('FAILED');
        });

        it('should continue workflow when command step fails with allow_failure set to true', async () => {
          const workflowFile = join(testDir, 'allow-failure-workflow.yml');
          writeFileSync(workflowFile, commandAllowFailureWorkflowYaml);

          await runRover(['workflows', 'add', workflowFile, '--json']);

          const result = await runRover([
            'task',
            '-y',
            'Run allow-failure workflow',
            '--workflow',
            'command-allow-failure',
            '--json',
          ]);

          expect(result.exitCode).toBe(0);

          const status = await waitForTaskTerminal(1);
          // Workflow should complete because allow_failure is true
          expect(status).toBe('COMPLETED');
        });

        it('should execute mixed workflow with both agent and command steps in correct order', async () => {
          const workflowFile = join(testDir, 'mixed-workflow.yml');
          writeFileSync(workflowFile, mixedWorkflowYaml);

          await runRover(['workflows', 'add', workflowFile, '--json']);

          const result = await runRover([
            'task',
            '-y',
            'Run mixed workflow',
            '--workflow',
            'mixed-workflow',
            '--json',
          ]);

          expect(result.exitCode).toBe(0);

          const status = await waitForTaskTerminal(1);
          // Mixed workflow should complete with both step types
          expect(['COMPLETED', 'FAILED']).toContain(status);
        });
      }
    );
  });
});

/**
 * ============================================================================
 * AUTOGENERATED E2E TEST FILE - DO NOT MODIFY MANUALLY
 * ============================================================================
 *
 * To modify these tests, update the specification files:
 * - /docs/E2E_TESTS.md (root-level testing philosophy and constraints)
 * - /packages/cli/E2E_TESTS.md (CLI-specific test specifications)
 *
 * Then run the /update-e2e-tests command to regenerate this file.
 * ============================================================================
 */
