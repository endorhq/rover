import { describe, expect, it, vi, beforeEach, afterEach } from 'vitest';
import { mkdtempSync, writeFileSync, rmSync } from 'node:fs';
import { join } from 'node:path';
import { tmpdir } from 'node:os';
import { ProjectConfigManager } from 'rover-core';

vi.mock('../sandbox/container-common.js', () => ({
  getDefaultAgentImage: vi.fn(() => 'ghcr.io/endorhq/rover/agent:v1.0.0'),
}));

import {
  DockerfileBuilder,
  getLanguagePackages,
  getPackageManagerPackages,
  getTaskManagerPackages,
} from '../dockerfile-builder.js';

describe('DockerfileBuilder', () => {
  let testDir: string;

  beforeEach(() => {
    testDir = mkdtempSync(join(tmpdir(), 'dockerfile-builder-test-'));
  });

  afterEach(() => {
    rmSync(testDir, { recursive: true, force: true });
  });

  function createProjectConfig(config: {
    languages?: string[];
    packageManagers?: string[];
    taskManagers?: string[];
  }): ProjectConfigManager {
    const roverJson = {
      version: '1.3',
      languages: config.languages || [],
      mcps: [],
      packageManagers: config.packageManagers || [],
      taskManagers: config.taskManagers || [],
      attribution: true,
    };
    writeFileSync(join(testDir, 'rover.json'), JSON.stringify(roverJson));
    return ProjectConfigManager.load(testDir);
  }

  describe('getLanguagePackages', () => {
    it('returns empty array for no languages', () => {
      const config = createProjectConfig({ languages: [] });
      const packages = getLanguagePackages(config);
      expect(packages).toHaveLength(0);
    });

    it('returns javascript package', () => {
      const config = createProjectConfig({ languages: ['javascript'] });
      const packages = getLanguagePackages(config);
      expect(packages).toHaveLength(1);
      expect(packages[0].name).toBe('javascript');
    });

    it('returns multiple language packages', () => {
      const config = createProjectConfig({
        languages: ['javascript', 'python', 'go'],
      });
      const packages = getLanguagePackages(config);
      expect(packages).toHaveLength(3);
      expect(packages.map(p => p.name)).toEqual(['javascript', 'python', 'go']);
    });

    it('returns all supported languages', () => {
      const config = createProjectConfig({
        languages: [
          'javascript',
          'typescript',
          'php',
          'rust',
          'go',
          'python',
          'ruby',
        ],
      });
      const packages = getLanguagePackages(config);
      expect(packages).toHaveLength(7);
    });
  });

  describe('getPackageManagerPackages', () => {
    it('returns empty array for no package managers', () => {
      const config = createProjectConfig({ packageManagers: [] });
      const packages = getPackageManagerPackages(config);
      expect(packages).toHaveLength(0);
    });

    it('returns pnpm package', () => {
      const config = createProjectConfig({ packageManagers: ['pnpm'] });
      const packages = getPackageManagerPackages(config);
      expect(packages).toHaveLength(1);
      expect(packages[0].name).toBe('pnpm');
    });

    it('returns all supported package managers', () => {
      const config = createProjectConfig({
        packageManagers: [
          'npm',
          'pnpm',
          'yarn',
          'composer',
          'cargo',
          'gomod',
          'pip',
          'poetry',
          'uv',
          'rubygems',
        ],
      });
      const packages = getPackageManagerPackages(config);
      expect(packages).toHaveLength(10);
    });
  });

  describe('getTaskManagerPackages', () => {
    it('returns empty array for no task managers', () => {
      const config = createProjectConfig({ taskManagers: [] });
      const packages = getTaskManagerPackages(config);
      expect(packages).toHaveLength(0);
    });

    it('returns make package', () => {
      const config = createProjectConfig({ taskManagers: ['make'] });
      const packages = getTaskManagerPackages(config);
      expect(packages).toHaveLength(1);
      expect(packages[0].name).toBe('make');
    });

    it('returns all supported task managers', () => {
      const config = createProjectConfig({
        taskManagers: ['just', 'make', 'task'],
      });
      const packages = getTaskManagerPackages(config);
      expect(packages).toHaveLength(3);
    });
  });

  describe('generate', () => {
    it('generates Dockerfile with correct header', () => {
      const config = createProjectConfig({});
      const builder = new DockerfileBuilder(config);
      const dockerfile = builder.generate();

      expect(dockerfile).toContain('# Generated by: rover image build');
      expect(dockerfile).toContain(
        '# Regenerate with: rover image build --force'
      );
    });

    it('generates Dockerfile with base image ARG', () => {
      const config = createProjectConfig({});
      const builder = new DockerfileBuilder(config);
      const dockerfile = builder.generate();

      expect(dockerfile).toContain(
        'ARG BASE_IMAGE=ghcr.io/endorhq/rover/agent:v1.0.0'
      );
      expect(dockerfile).toContain('FROM ${BASE_IMAGE}');
    });

    it('generates Dockerfile with project labels', () => {
      const config = createProjectConfig({});
      const builder = new DockerfileBuilder(config);
      const dockerfile = builder.generate();

      expect(dockerfile).toContain('LABEL rover.generated=true');
      expect(dockerfile).toContain('LABEL rover.project=');
    });

    it('generates empty Dockerfile for project with no packages', () => {
      const config = createProjectConfig({});
      const builder = new DockerfileBuilder(config);
      const dockerfile = builder.generate();

      // Should not have apt-get install
      expect(dockerfile).not.toContain('apt-get install');
      // Should not have RUN commands except in labels section
      expect(dockerfile).not.toContain('RUN npm');
    });

    it('combines apt-get packages into single RUN command', () => {
      const config = createProjectConfig({
        languages: ['python', 'go'],
        taskManagers: ['make'],
      });
      const builder = new DockerfileBuilder(config);
      const dockerfile = builder.generate();

      // Should have single apt-get update && apt-get install
      const aptMatches = dockerfile.match(/apt-get update/g);
      expect(aptMatches).toHaveLength(1);

      // Should contain all packages
      expect(dockerfile).toContain('python3-dev');
      expect(dockerfile).toContain('golang-go');
      expect(dockerfile).toContain('make');
    });

    it('generates separate RUN for non-apt packages', () => {
      const config = createProjectConfig({
        packageManagers: ['pnpm'],
      });
      const builder = new DockerfileBuilder(config);
      const dockerfile = builder.generate();

      expect(dockerfile).toContain('RUN npm install -g pnpm');
    });

    it('generates init scripts for packages that need them', () => {
      const config = createProjectConfig({
        languages: ['javascript', 'go'],
      });
      const builder = new DockerfileBuilder(config);
      const dockerfile = builder.generate();

      // JavaScript init
      expect(dockerfile).toContain('# Initialize javascript');
      expect(dockerfile).toContain('mkdir -p $HOME/.local/npm');

      // Go init
      expect(dockerfile).toContain('# Initialize go');
      expect(dockerfile).toContain('mkdir -p $HOME/go/bin');
    });

    it('properly formats multi-line scripts with && chains', () => {
      const config = createProjectConfig({
        languages: ['javascript'],
      });
      const builder = new DockerfileBuilder(config);
      const dockerfile = builder.generate();

      // Should have proper && chain formatting
      expect(dockerfile).toMatch(/RUN .+ \\\n\s+&& /);
    });
  });

  describe('getImageTag', () => {
    it('generates tag based on project directory name', () => {
      const config = createProjectConfig({});
      const builder = new DockerfileBuilder(config);
      const tag = builder.getImageTag();

      expect(tag).toMatch(/^rover-.+:latest$/);
    });

    it('sanitizes special characters in project name', () => {
      // The tag is based on testDir basename which has random chars
      const config = createProjectConfig({});
      const builder = new DockerfileBuilder(config);
      const tag = builder.getImageTag();

      // Should only contain lowercase letters, numbers, and dashes
      expect(tag).toMatch(/^rover-[a-z0-9-]+:latest$/);
    });
  });

  describe('getBaseImage', () => {
    it('returns default agent image', () => {
      const config = createProjectConfig({});
      const builder = new DockerfileBuilder(config);
      expect(builder.getBaseImage()).toBe('ghcr.io/endorhq/rover/agent:v1.0.0');
    });

    it('returns custom base image when provided', () => {
      const config = createProjectConfig({});
      const builder = new DockerfileBuilder(config, {
        baseImage: 'custom-image:v2.0.0',
      });
      expect(builder.getBaseImage()).toBe('custom-image:v2.0.0');
    });
  });
});
